'use client'

import React, {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react'
import SockJS from 'sockjs-client'
import { Client, Message } from 'stompjs'

// WebSocket Î©îÏãúÏßÄ ÌÉÄÏûÖ Ï†ïÏùò
export interface WebSocketMessage {
  type:
    | 'CHAT'
    | 'BID'
    | 'AUCTION_TIMER'
    | 'NOTIFICATION'
    | 'SYSTEM'
    | 'HOME_UPDATE'
    | 'POPULAR_PRODUCTS'
    | 'RECENT_BIDS'
    | 'ENDING_SOON'
    | 'AUCTION_STATS'
    | 'BID_UPDATE'
    | 'AUCTION_END'
    | 'RANKING_UPDATE'
    | 'NEW_BID_RANKING'
    | 'RANKING_REFRESH'
  sender?: string
  content: string
  data?: any
  timestamp?: string
}

// WebSocket Context ÌÉÄÏûÖ Ï†ïÏùò
interface WebSocketContextType {
  isConnected: boolean
  connect: () => void
  disconnect: () => void
  subscribe: (
    destination: string,
    callback: (message: WebSocketMessage) => void,
  ) => string
  unsubscribe: (subscriptionId: string) => void
  sendMessage: (destination: string, message: any) => void
  subscribeToBidUpdates: (
    productId: number,
    callback: (message: WebSocketMessage) => void,
  ) => string
  subscribeToNotifications: (
    callback: (message: WebSocketMessage) => void,
  ) => string
}

const WebSocketContext = createContext<WebSocketContextType | undefined>(
  undefined,
)

interface WebSocketProviderProps {
  children: React.ReactNode
}

export function WebSocketProvider({ children }: WebSocketProviderProps) {
  const [isConnected, setIsConnected] = useState(false)
  const stompClientRef = useRef<Client | null>(null)
  const subscriptionsRef = useRef<Map<string, any>>(new Map())
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectAttemptsRef = useRef(0)
  const maxReconnectAttempts = 5

  // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Íµ¨ÎèÖ Í¥ÄÎ¶¨
  const subscriptionCallbacksRef = useRef<
    Map<string, (message: WebSocketMessage) => void>
  >(new Map())
  const isConnectingRef = useRef(false)

  // WebSocket Ïó∞Í≤∞ Ìï®Ïàò
  const connect = () => {
    if (stompClientRef.current?.connected || isConnectingRef.current) {
      console.log('üîå WebSocket Ïù¥ÎØ∏ Ïó∞Í≤∞Îê® ÎòêÎäî Ïó∞Í≤∞ Ï§ë')
      return
    }

    isConnectingRef.current = true

    try {
      console.log('üîå WebSocket Ïó∞Í≤∞ ÏãúÎèÑ...')

      // STOMP ÎùºÏù¥Î∏åÎü¨Î¶¨ ÌôïÏù∏
      if (!(window as any).Stomp) {
        console.error('üîå STOMP ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§')
        handleReconnect()
        return
      }

      // Î∞±ÏóîÎìú API ÏóîÎìúÌè¨Ïù∏Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
      const getBackendUrl = () => {
        // ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú Î∞±ÏóîÎìú URL Í∞ÄÏ†∏Ïò§Í∏∞ (Í∏∞Î≥∏Í∞í: localhost:8080)
        const apiBaseUrl =
          process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8080'
        return `${apiBaseUrl}/ws`
      }

      // SockJS Ïó∞Í≤∞ ÏÉùÏÑ±
      const backendUrl = getBackendUrl()
      console.log('üîå WebSocket Ïó∞Í≤∞ URL:', backendUrl)

      // CORS Î¨∏Ï†ú Ìï¥Í≤∞ÏùÑ ÏúÑÌïú ÏòµÏÖò Ï∂îÍ∞Ä
      const socket = new SockJS(backendUrl, null, {
        transports: ['websocket', 'xhr-polling', 'xhr-streaming'],
      })
      const stompClient = (window as any).Stomp.over(socket)

      // ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÎπÑÌôúÏÑ±Ìôî (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
      stompClient.debug = (str: string) => {
        // Ï§ëÏöîÌïú Î©îÏãúÏßÄÎßå Î°úÍπÖ
        if (
          str.includes('CONNECTED') ||
          str.includes('ERROR') ||
          str.includes('DISCONNECT')
        ) {
          console.log('üîå STOMP:', str)
        }
      }

      // Ïó∞Í≤∞ ÏÑ§Ï†ï
      const getAccessToken = () => {
        const cookies = document.cookie.split(';')
        const accessTokenCookie = cookies.find((cookie) =>
          cookie.trim().startsWith('accessToken='),
        )
        return accessTokenCookie?.split('=')[1] || null
      }

      const accessToken = getAccessToken()
      const connectHeaders = accessToken
        ? {
            Authorization: `Bearer ${accessToken}`,
          }
        : {}

      stompClient.connect(
        connectHeaders,
        (frame: any) => {
          console.log('üîå WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ:', frame)
          setIsConnected(true)
          stompClientRef.current = stompClient
          reconnectAttemptsRef.current = 0
          isConnectingRef.current = false

          // Ïó∞Í≤∞ ÏÑ±Í≥µ Ïãú Í∏∞Ï°¥ Íµ¨ÎèÖ Î≥µÏõê
          restoreSubscriptions()
        },
        (error: any) => {
          console.error('üîå WebSocket Ïó∞Í≤∞ Ïã§Ìå®:', error)
          console.error('üîå Ïó∞Í≤∞ Ïã§Ìå® ÏÉÅÏÑ∏:', {
            error,
            accessToken: accessToken ? 'ÏûàÏùå' : 'ÏóÜÏùå',
            headers: connectHeaders,
          })
          setIsConnected(false)
          isConnectingRef.current = false
          handleReconnect()
        },
      )

      stompClientRef.current = stompClient
    } catch (error) {
      console.error('üîå WebSocket Ïó∞Í≤∞ Ïò§Î•ò:', error)
      isConnectingRef.current = false
      handleReconnect()
    }
  }

  // Ïû¨Ïó∞Í≤∞ Ï≤òÎ¶¨
  const handleReconnect = () => {
    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {
      console.error('üîå ÏµúÎåÄ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º')
      return
    }

    const delay = Math.min(
      1000 * Math.pow(2, reconnectAttemptsRef.current),
      30000,
    )
    reconnectAttemptsRef.current++

    console.log(
      `üîå ${delay}ms ÌõÑ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ (${reconnectAttemptsRef.current}/${maxReconnectAttempts})`,
    )

    reconnectTimeoutRef.current = setTimeout(() => {
      connect()
    }, delay)
  }

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  const disconnect = () => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }

    if (stompClientRef.current?.connected) {
      console.log('üîå WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú')
      stompClientRef.current.disconnect(() => {
        console.log('üîå WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú ÏôÑÎ£å')
      })
    }

    setIsConnected(false)
    stompClientRef.current = null
    subscriptionsRef.current.clear()
    subscriptionCallbacksRef.current.clear()
    reconnectAttemptsRef.current = 0
    isConnectingRef.current = false
  }

  // Íµ¨ÎèÖ Î≥µÏõê
  const restoreSubscriptions = () => {
    console.log('üîå Íµ¨ÎèÖ Î≥µÏõê ÏãúÏûë')

    // Ï†ÄÏû•Îêú ÏΩúÎ∞±Îì§ÏùÑ Îã§Ïãú Íµ¨ÎèÖ
    subscriptionCallbacksRef.current.forEach((callback, destination) => {
      if (!subscriptionsRef.current.has(destination)) {
        const subscription = stompClientRef.current?.subscribe(
          destination,
          (message: Message) => {
            try {
              const parsedMessage: WebSocketMessage = JSON.parse(message.body)
              callback(parsedMessage)
            } catch (error) {
              console.error('üîå Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', error, message.body)
            }
          },
        )

        if (subscription) {
          subscriptionsRef.current.set(destination, subscription)
          console.log('üîå Íµ¨ÎèÖ Î≥µÏõê:', destination)
        }
      }
    })
  }

  // ÏùºÎ∞ò Íµ¨ÎèÖ
  const subscribe = (
    destination: string,
    callback: (message: WebSocketMessage) => void,
  ): string => {
    if (!stompClientRef.current?.connected) {
      console.warn('üîå WebSocketÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå, Íµ¨ÎèÖ Ïã§Ìå®:', destination)
      // Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ ÏΩúÎ∞±Îßå Ï†ÄÏû•ÌïòÍ≥† ÎÇòÏ§ëÏóê Ïó∞Í≤∞ Ïãú Íµ¨ÎèÖ
      subscriptionCallbacksRef.current.set(destination, callback)
      return destination
    }

    // Ï§ëÎ≥µ Íµ¨ÎèÖ Î∞©ÏßÄ
    if (subscriptionsRef.current.has(destination)) {
      console.log('üîå Ïù¥ÎØ∏ Íµ¨ÎèÖ Ï§ë:', destination)
      return destination
    }

    // ÏΩúÎ∞± Ï†ÄÏû•
    subscriptionCallbacksRef.current.set(destination, callback)

    const subscription = stompClientRef.current.subscribe(
      destination,
      (message: Message) => {
        try {
          const parsedMessage: WebSocketMessage = JSON.parse(message.body)
          console.log('üîå Î©îÏãúÏßÄ ÏàòÏã†:', destination, parsedMessage)
          console.log('üîå ÏõêÎ≥∏ Î©îÏãúÏßÄ body:', message.body)
          callback(parsedMessage)
        } catch (error) {
          console.error('üîå Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', error, message.body)
        }
      },
    )

    subscriptionsRef.current.set(destination, subscription)
    console.log('üîå Íµ¨ÎèÖ ÏÑ±Í≥µ:', destination)
    return destination
  }

  // Íµ¨ÎèÖ Ìï¥Ï†ú
  const unsubscribe = (subscriptionId: string) => {
    console.log('üîå unsubscribe Ìò∏Ï∂úÎê®:', subscriptionId)
    console.log(
      'üîå ÌòÑÏû¨ Íµ¨ÎèÖ Î™©Î°ù:',
      Array.from(subscriptionsRef.current.keys()),
    )

    const subscription = subscriptionsRef.current.get(subscriptionId)
    if (subscription) {
      subscription.unsubscribe()
      subscriptionsRef.current.delete(subscriptionId)
      subscriptionCallbacksRef.current.delete(subscriptionId)
      console.log('üîå Íµ¨ÎèÖ Ìï¥Ï†ú ÏôÑÎ£å:', subscriptionId)
    } else {
      console.log('üîå Íµ¨ÎèÖÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå:', subscriptionId)
    }
  }

  // Î©îÏãúÏßÄ Ï†ÑÏÜ°
  const sendMessage = (destination: string, message: any) => {
    if (!stompClientRef.current?.connected) {
      console.warn(
        'üîå WebSocketÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå, Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:',
        destination,
      )
      return
    }

    try {
      stompClientRef.current.send(destination, {}, JSON.stringify(message))
      console.log('üîå Î©îÏãúÏßÄ Ï†ÑÏÜ°:', destination, message)
    } catch (error) {
      console.error('üîå Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïò§Î•ò:', error)
    }
  }

  // ÏûÖÏ∞∞ ÏóÖÎç∞Ïù¥Ìä∏ Íµ¨ÎèÖ (Ìé∏Ïùò Ìï®Ïàò)
  const subscribeToBidUpdates = (
    productId: number,
    callback: (message: WebSocketMessage) => void,
  ): string => {
    const destination = `/topic/bid/${productId}`
    return subscribe(destination, callback)
  }

  // Í∞úÏù∏ ÏïåÎ¶º Íµ¨ÎèÖ (Ìé∏Ïùò Ìï®Ïàò)
  const subscribeToNotifications = (
    callback: (message: WebSocketMessage) => void,
  ): string => {
    const destination = '/user/queue/notifications'
    return subscribe(destination, callback)
  }

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú ÏûêÎèô Ïó∞Í≤∞
  useEffect(() => {
    connect()

    // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ïó∞Í≤∞ Ìï¥Ï†ú
    return () => {
      disconnect()
    }
  }, [])

  // ÌéòÏù¥ÏßÄ Í∞ÄÏãúÏÑ± Î≥ÄÍ≤Ω Ïãú Ïó∞Í≤∞ ÏÉÅÌÉú Í¥ÄÎ¶¨
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        // ÌéòÏù¥ÏßÄÍ∞Ä Ïà®Í≤®ÏßÄÎ©¥ Ïó∞Í≤∞ Ïú†ÏßÄ (Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑúÎèÑ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî)
        console.log('üîå ÌéòÏù¥ÏßÄ Ïà®ÍπÄ - Ïó∞Í≤∞ Ïú†ÏßÄ')
      } else {
        // ÌéòÏù¥ÏßÄÍ∞Ä Îã§Ïãú Î≥¥Ïù¥Î©¥ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
        if (!isConnected && !stompClientRef.current?.connected) {
          console.log('üîå ÌéòÏù¥ÏßÄ Î≥µÏõê - Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ')
          connect()
        }
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [isConnected])

  const contextValue: WebSocketContextType = {
    isConnected,
    connect,
    disconnect,
    subscribe,
    unsubscribe,
    sendMessage,
    subscribeToBidUpdates,
    subscribeToNotifications,
  }

  return (
    <WebSocketContext.Provider value={contextValue}>
      {children}
    </WebSocketContext.Provider>
  )
}

// WebSocket Context ÏÇ¨Ïö©ÏùÑ ÏúÑÌïú ÌõÖ
export function useWebSocket() {
  const context = useContext(WebSocketContext)
  if (context === undefined) {
    throw new Error('useWebSocketÏùÄ WebSocketProvider ÎÇ¥ÏóêÏÑú ÏÇ¨Ïö©ÎêòÏñ¥Ïïº Ìï©ÎãàÎã§')
  }
  return context
}

// WebSocket Ïó∞Í≤∞ ÏÉÅÌÉúÎ•º ÌëúÏãúÌïòÎäî Ïª¥Ìè¨ÎÑåÌä∏
export function WebSocketStatus() {
  const { isConnected, connect } = useWebSocket()

  return (
    <div className="fixed right-4 bottom-4 z-50">
      <div
        className={`flex cursor-pointer items-center space-x-2 rounded-full px-3 py-2 text-sm font-medium ${
          isConnected
            ? 'bg-green-100 text-green-800'
            : 'bg-red-100 text-red-800'
        }`}
        onClick={() => {
          if (!isConnected) {
            console.log('üîå ÏàòÎèô Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ')
            connect()
          }
        }}
        title={isConnected ? 'Ïã§ÏãúÍ∞Ñ Ïó∞Í≤∞Îê®' : 'ÌÅ¥Î¶≠ÌïòÏó¨ Ïû¨Ïó∞Í≤∞'}
      >
        <div
          className={`h-2 w-2 rounded-full ${
            isConnected ? 'bg-green-500' : 'bg-red-500'
          }`}
        />
        <span>{isConnected ? 'Ïã§ÏãúÍ∞Ñ Ïó∞Í≤∞Îê®' : 'Ïó∞Í≤∞ ÎÅäÍπÄ'}</span>
      </div>
    </div>
  )
}
